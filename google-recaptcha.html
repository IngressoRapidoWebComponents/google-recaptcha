<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-form-element-behavior/iron-form-element-behavior.html">
<link rel="import" href="../iron-validatable-behavior/iron-validatable-behavior.html">
<link rel="import" href="../promise-polyfill/promise-polyfill-lite.html">
<link rel="import" href="iron-scroll-fit.html">

<script>
  window.onloadGrecaptchaCallback = function() {
    this.dispatchEvent(new Event('grecaptcha-loaded'));
  }
</script>
<!-- TODO: Add hl config in some way-->
<script src="https://www.google.com/recaptcha/api.js?onload=onloadGrecaptchaCallback&render=explicit" async defer></script>

<!--
`google-recaptcha`

@demo demo/index.html
-->


<dom-module id="google-recaptcha">
  <style>
    :host {
      display: block;
    }
    :host([hidden]) {
      display: none !important;
    }
    :host(:not([invisible])) {
      width: 302px;
      height: 78px;
    }
    :host([compact]) {
      width: 164px;
      height: 144px;
    }
    :host([invisible][badge="inline"]) {
      width: 256px;
      height: 60px;
    }
  </style>
  <template>

    <iron-scroll-fit
      id="container"
      hidden$="[[hidden]]"
      scroll-target="{{scrollTarget}}"
      horizontal-align="left"
      vertical-align="top"
    ></iron-scroll-fit>

  </template>
  <script>


    Polymer({

      is: 'google-recaptcha',

      behaviors: [
        Polymer.IronFormElementBehavior,
        Polymer.IronValidatableBehavior
      ],

      properties: {
        inBodyDisabled: {
          type: Boolean,
          value: false
        },
        fitOnScrollDisabled: {
          type: Boolean,
          value: false
        },
        /**
        * Specifies the element that will handle the scroll event
        * on the behalf of the current element. This is typically a reference to an element,
        * but there are a few more posibilities:
        *
        * ### Elements id
        *
        *```html
        * <div id="scrollable-element" style="overflow: auto;">
        *  <google-recaptcha scroll-target="scrollable-element"></google-recaptcha>
        * </div>
        *```
        * In this case, the `scrollTarget` will point to the outer div element.
        *
        * ### Document scrolling
        *
        * For document scrolling, you can use the reserved word `document`:
        *
        *```html
        * <google-recaptcha scroll-target="document"></google-recaptcha>
        *```
        *
        * ### Elements reference
        *
        *```js
        * recaptcha.scrollTarget = document.querySelector('#scrollable-element');
        *```
        *
        * @type {HTMLElement}
        * @default document
        */
        scrollTarget: {
          type: HTMLElement
        },
        invisible: {
          type: Boolean,
          value: false,
          reflectToAttribute: true
        },
        preventAutoRender: {
          type: Boolean,
          value: false
        },
        rendered: {
          type: Boolean,
          computed: '_computeRendered(widgetId)',
          notify: true
        },
        loaded: {
          type: Boolean,
          readOnly: true,
          notify: true,
          value: function() {
            return !!window.grecaptcha
          }
        },
        widgetId: {
          type: String,
          readOnly: true,
          notify: true
        },
        sitekey: {
          type: String
        },
        /**
         * Not working for now
         */
        loading: {
          type: Boolean,
          value: false
        },
        container: {
          type: Object
        },
        responseCallback: {
          type: Function,
          value: function() {
            return function(token) {
              this._setValue(token);
              this._setExpired(false);
              this.resolveCompletes(token);
              this.dispatchEvent(new CustomEvent(
                'google-recaptcha-response',
                {detail: token, bubbles: true, composed: true}
              ));
            }.bind(this)
          }
        },
        expiredCallback: {
          type: Function,
          value: function() {
            return function() {
              this._setValue('');
              this._setExpired(true);
              this.dispatchEvent(new CustomEvent(
                'google-recaptcha-expired',
                {bubbles: true, composed: true}
              ));
            }.bind(this)
          }
        },
        expired: {
          type: Boolean,
          value: false,
          readOnly: true,
          notify: true
        },
        value: {
          type: String,
          readOnly: true,
          notify: true
        },
        audio: {
          type: Boolean,
          value: false
        },
        compact: {
          type: Boolean,
          value: false
        },
        tabindex: {
          type: Number,
          value: 0
        },
        dark: {
          type: Boolean,
          value: false
        },
        /**
         * {bottomright | bottomleft | inline}
         * For invisible only.
         * Reposition the reCAPTCHA badge. 'inline' allows you to control the CSS.
         */
        badge: {
          type: String,
          value: 'bottomright',
          reflectToAttribute: true
        },
        /**
         * A promise that resolves when the grecaptcha response comes back.
         *
         * @type {Promise}
         */
        completes: {
          type: Object,
          readOnly: true,
          notify: true,
          value: function() {
            return new Promise(function (resolve, reject) {
              this.resolveCompletes = resolve;
              this.rejectCompletes = reject;
            }.bind(this));
          }
        },
        inBody: {
          type: Boolean,
          value: false,
          readOnly: true,
          notify: true
        },
        hidden: {
          type: Boolean,
          value: false,
          reflectToAttribute: true
        },
        _size: {
          type: String,
          computed: '_compute_size(invisible, compact)'
        },
        _theme: {
          type: String,
          computed: '_compute_theme(dark)'
        },
        _type: {
          type: String,
          computed: '_compute_type(audio)'
        },
      },

      /**
       * Fired when a recaptcha response is recieved.
       *
       * @event google-recaptcha-response
       */

      /**
       * Fired when a recaptcha expires.
       *
       * @event google-recaptcha-expired
       */

      observers: [
        '_autoRenderIfNeeded(preventAutoRender, loaded, container, sitekey)',
        '_updateScrollListener(invisible, badge, fitOnScrollDisabled, container)',
        '_updatePosition(inBodyDisabled, container)',
        '_fitIfNeeded(inBody, fitOnScrollDisabled, hidden, container)',
      ],

      attached: function() {
        var container = this.$.container;
        container.fitInto = this;
        this.container = container;
        window.addEventListener('grecaptcha-loaded', function() {
          this._setLoaded(true);
        }.bind(this));
      },

      detached: function() {
        // TODO: remove event listener
      },

      _compute_size: function(invisible, compact) {
        return invisible ? 'invisible' : (compact ? 'compact' : 'normal');
      },

      _compute_theme: function(dark) {
        return dark ? 'dark' : 'light';
      },

      _compute_type: function(audio) {
        return audio ? 'audio' : 'image';
      },

      _computeRendered: function(widgetId) {
        return !isNaN(widgetId);
      },

      _fitIfNeeded(inBody, fitOnScrollDisabled, hidden, container) {
        if (inBody && !fitOnScrollDisabled && !hidden) {
          container.fit();
        }
      },

      _updateScrollListener(invisible, badge, fitOnScrollDisabled, container) {
        container.toggleScrollListener(!fitOnScrollDisabled && !invisible || badge === 'inline');
      },

      _updatePosition(inBodyDisabled, container) {
        if (!inBodyDisabled) {
          !this.inBody && Polymer.dom(document.body).appendChild(container);
          this._setInBody(true);
        } else if (this.inBody){
          Polymer.dom(this.root).appendChild(container);
          container.resetFit();
          this._setInBody(false);
        }
      },

      _autoRenderIfNeeded: function(preventAutoRender, loaded, container) {
        if(!preventAutoRender && loaded && container) {
          this.render();
        }
      },

      getResponse: function() {
        if (this.rendered) {
          return window.grecaptcha.getResponse(this.widgetId);
        }
      },

      execute: function() {
        if (this.rendered && this.invisible) {
          window.grecaptcha.execute(this.widgetId);
          return this.completes;
        }
      },

      reset: function() {
        if (this.rendered) {
          this._setValue('');
          window.grecaptcha.reset(this.widgetId);
        }
      },

      render: function() {
        if (!this.rendered && this.sitekey) {
          this._setWidgetId(window.grecaptcha.render(this.container, {
            'sitekey': this.sitekey,
            'size': this._size,
            'tabindex': this.tabindex,
            'callback': this.responseCallback.bind(this),
            'expired-callback': this.expiredCallback.bind(this),
            'theme': this._theme,
            'type': this._type,
            'badge': this.badge
          }));
        }
      },

      _getValidity: function() {
        return !!this.value;
      },

    });

  </script>
</dom-module>
