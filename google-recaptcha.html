<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-form-element-behavior/iron-form-element-behavior.html">
<link rel="import" href="../iron-validatable-behavior/iron-validatable-behavior.html">

<script>
  window.onloadGrecaptchaCallback = function() {
    this.dispatchEvent(new Event('grecaptcha-loaded'));
  }
</script>
<!-- TODO: Add hl config in some way-->
<script src="https://www.google.com/recaptcha/api.js?onload=onloadGrecaptchaCallback&render=explicit" async defer></script>

<!--
`google-recaptcha`

@demo demo/index.html
-->


<dom-module id="google-recaptcha">
  <template>

    <div id="container"></div>

  </template>
  <script>


    Polymer({

      is: 'google-recaptcha',

      behaviors: [
        Polymer.IronFormElementBehavior,
        Polymer.IronValidatableBehavior
      ],

      properties: {
        invisible: {
          type: Boolean,
          value: false
        },
        preventAutoRender: {
          type: Boolean,
          value: false
        },
        rendered: {
          type: Boolean,
          computed: '_computeRendered(widgetId)',
          notify: true
        },
        loaded: {
          type: Boolean,
          readOnly: true,
          notify: true,
          value: function() {
            return !!window.grecaptcha
          }
        },
        widgetId: {
          type: String,
          readOnly: true,
          notify: true
        },
        sitekey: {
          type: String
        },
        /**
         * Not working for now
         */
        loading: {
          type: Boolean,
          value: false
        },
        container: {
          type: HTMLElement
        },
        responseCallback: {
          type: Function,
          value: function() {
            return function(token) {
              this._setValue(token);
              this._setExpired(false);
              this.resolveCompletes(token);
              this.dispatchEvent(new CustomEvent(
                'google-recaptcha-response',
                {detail: token, bubbles: true, composed: true}
              ));
            }.bind(this)
          }
        },
        expiredCallback: {
          type: Function,
          value: function() {
            return function() {
              this._setValue('');
              this._setExpired(true);
              this.dispatchEvent(new CustomEvent(
                'google-recaptcha-expired',
                {bubbles: true, composed: true}
              ));
            }.bind(this)
          }
        },
        expired: {
          type: Boolean,
          value: false,
          readOnly: true,
          notify: true
        },
        value: {
          type: String,
          readOnly: true,
          notify: true,
          value: ''
        },
        audio: {
          type: Boolean,
          value: false
        },
        compact: {
          type: Boolean,
          value: false
        },
        tabindex: {
          type: Number,
          value: 0
        },
        dark: {
          type: Boolean,
          value: false
        },
        /**
         * {bottomright | bottomleft | inline}
         * For invisible only.
         * Reposition the reCAPTCHA badge. 'inline' allows you to control the CSS.
         */
        badge: {
          type: String,
          value: 'bottomright'
        },
        /**
         * A promise that resolves when the grecaptcha response comes back.
         *
         * @type {Promise}
         */
        completes: {
          type: Object,
          readOnly: true,
          notify: true,
          value: function() {
            return new Promise(function (resolve, reject) {
              this.resolveCompletes = resolve;
              this.rejectCompletes = reject;
            }.bind(this));
          }
        },
        _size: {
          type: String,
          computed: '_compute_size(invisible, compact)'
        },
        _theme: {
          type: String,
          computed: '_compute_theme(dark)'
        },
        _type: {
          type: String,
          computed: '_compute_type(audio)'
        },
      },


      /**
       * Fired when a recaptcha response is recieved.
       *
       * @event google-recaptcha-response
       */

      /**
       * Fired when a recaptcha expires.
       *
       * @event google-recaptcha-expired
       */

      observers: [
        '_autoRenderIfNeeded(preventAutoRender, loaded, container, sitekey)'
      ],

      attached: function() {
        this.container = this.$.container;
        window.addEventListener('grecaptcha-loaded', function() {
          this._setLoaded(true);
        }.bind(this));
      },

      detached: function() {
        // TODO: remove event listener
      },

      _compute_size: function(invisible, compact) {
        return invisible ? 'invisible' : (compact ? 'compact' : 'normal');
      },

      _compute_theme: function(dark) {
        return dark ? 'dark' : 'light';
      },

      _compute_type: function(audio) {
        return audio ? 'audio' : 'image';
      },

      _computeRendered: function(widgetId) {
        return !isNaN(widgetId);
      },

      _autoRenderIfNeeded: function(preventAutoRender, loaded, container) {
        if(!preventAutoRender && loaded && container) {
          this.render();
        }
      },

      getResponse: function() {
        if (this.rendered) {
          return window.grecaptcha.getResponse(this.widgetId);
        }
      },

      execute: function() {
        if (this.rendered && this.invisible) {
          window.grecaptcha.execute(this.widgetId);
          return this.completes;
        }
      },

      reset: function() {
        if (this.rendered) {
          this._setValue('');
          window.grecaptcha.reset(this.widgetId);
        }
      },

      render: function() {
        if (!this.rendered && this.sitekey) {
          this._setWidgetId(window.grecaptcha.render(this.container, {
            'sitekey': this.sitekey,
            'size': this._size,
            'tabindex': this.tabindex,
            'callback': this.responseCallback.bind(this),
            'expired-callback': this.expiredCallback.bind(this),
            'theme': this._theme,
            'type': this._type,
            'badge': this.badge
          }));
        }
      },

      _getValidity: function() {
        return !!this.value;
      },

    });

  </script>
</dom-module>
